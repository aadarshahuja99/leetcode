class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // Key: identify components that only have one infected node. Of these components, take the component of the highest size.
        int n = graph.length;
        Arrays.sort(initial);
        DisjointSet ds = new DisjointSet(n);
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(i != j && graph[i][j] == 1)
                {
                    ds.union(i,j);
                }
            }
        }
        HashMap<Integer,ArrayList<Integer>> parentInfectedSources = new HashMap<>();
        for(int infected : initial)
        {
            int parent = ds.find(infected);
            if(!parentInfectedSources.containsKey(parent))
            {
                parentInfectedSources.put(parent, new ArrayList<>());
            }
            parentInfectedSources.get(parent).add(infected);
        }
        int ans = initial[0];
        int size = 0;
        for(Map.Entry<Integer,ArrayList<Integer>> entry : parentInfectedSources.entrySet())
        {
            int parent = entry.getKey();
            var sources = entry.getValue();
            if(sources.size() > 1)
            {
                continue;
            }
            int componentSize = ds.getComponentSizeByUltimateParent(parent);
            // System.out.println(componentSize+" "+sources.get(0));
            if(componentSize > size)
            {
                size = componentSize;
                ans = sources.get(0);
            }
            else if(componentSize == size && sources.get(0) < ans)
            {
                ans = sources.get(0);
            }
        }
        return ans;
    }
    class DisjointSet
    {
        int[] parent;
        int[] size;
        public DisjointSet(int n){
            parent = new int[n];
            size = new int[n];
            for(int i=0; i<n; i++)
            {
                parent[i] = i;
                size[i] = 1;
            }
        }
        public int find(int u)
        {
            return parent[u] = (parent[u] == u ? u : find(parent[u]));
        }
        public void union(int u, int v)
        {
            int uParent = find(u);
            int vParent = find(v);
            if(uParent == vParent)
            {
                return;
            }
            if(size[uParent] >= size[vParent])
            {
                size[uParent] += size[vParent];
                parent[vParent] = uParent;
            }
            else
            {
                size[vParent] += size[uParent];
                parent[uParent] = vParent;
            }
        }
        public int getComponentSizeByUltimateParent(int parent)
        {
            return size[parent];
        }
    }
}